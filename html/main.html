<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Type
import pandas as pd


class Amortizer:
    &#34;&#34;&#34;
    This Class instantiates an new object for a loan ammortization calculations. Attributes are used as initial values for two \n
    implemented methods of payment schedule: **annuity** and classic **straight** amortization.

    Attributes:
        amount (float): Loan body (i.e. 100000 or 900.50)
        period (int): Number of months (i.e. 5 years = 60)
        interest_rate (float): Interest rate in percents (i.e. if 9% then 9 without &#39;%&#39; sign. Decimal types: 9.5 are allowed.)

    Methods:
        straight_amortization(): Calculates amortization table with straight amortization and returns a dataframe. \n
        annuity_amortization(): Calculates amortization table with annuity payments and returns a dataframe. \n
        get_summary(method=&#34;straight&#34;): Calculates amortization dataframe and returns a dictionary with summary statistics. \n
        to_html(method=&#34;straight&#34;): Calculates amortization dataframe and exports results to a string with html markup.  \n
        to_json(method=&#34;straight&#34;): Calculates amortization dataframe and exports results to a string with JSON object. \n
        to_csvpath: str, method=&#34;annuity&#34;): Calculates amortization dataframe and exports results to .csv file. \n

    &#34;&#34;&#34;

    def __init__(self, amount: float, period: int, interest_rate: float):

        args = [amount, period, interest_rate]
        for arg in args:
            if type(arg) == str:
                raise TypeError(&#34;Arguments must be Integer or Float&#34;)

        if period &lt;= 0:
            raise ValueError(&#34;Period cannot be less than 0 months&#34;)
        if interest_rate &gt; 100 or interest_rate &lt; 0:
            raise ValueError(&#34;Interest rate per year cannot be more than 100 or less then 0%&#34;)

        self.amount = float(amount)
        self.period = period
        self.interest_rate = float(interest_rate)

    def straight_amortization(self):
        &#34;&#34;&#34;Calculates amortization table with straight amortization.
        A loan amortized in the classic method comprises a series of payments made between equal time intervals.\n
        Classic amortization means that the borrower will amortize an equal amount each payment period, but the interest will differ in size. \n
        Due to that the interest rate is based on the outstanding debt, the interest paid each payment period is going to decrease the further in to the loan period you get. \n
        Which means that in the beginning of the loan period, the payments will be the biggest and  in the end of the loan period the payments will get smaller and smaller.\n

        Returns:
            DataFrame: Returns pandas DataFrame with calculated values
        &#34;&#34;&#34;
       
        amortization = self.amount / self.period #constant amortization per month
        prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
        interest_rate_period = self.interest_rate / 1200

        df = pd.DataFrame(columns = [
        &#39;Year:Period&#39;, 
        &#39;Amortization&#39;,
        &#39;Interest expense&#39;,
        &#39;Payment&#39;,
        &#39;Remaining debt&#39;
        ])
        
        for i in range(0, self.period):    
            
            interest_exp = prev_rem_debt * interest_rate_period
            remaining_debt = prev_rem_debt - amortization
            prev_rem_debt = remaining_debt
            payment_amount = interest_exp + amortization
            new_row = {
                &#39;Month:Period&#39;: i + 1,
                &#39;Amortization&#39;: amortization,
                &#39;Interest expense&#39;: interest_exp,
                &#39;Payment&#39;: payment_amount,
                &#39;Remaining debt&#39;: prev_rem_debt,
            }
            
            df = df.append(new_row, ignore_index=True)
            df = df.round(2)
            df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )
        
        return df



    def annuity_amortization(self):
        &#34;&#34;&#34;Calculates amortization table with annuity payments\n
        A loan amortized in the annuity method comprises a series of payments made between equal time intervals. \n
        This amortization type is used to pay an equal amount each payment period. In the beginning of the loan period, \n
        the payments will consist of a bigger part interest and a smaller part amortization.\n
         The further towards the end of the loan period you will come, the bigger part of the payment will be amortization and the smaller part interest.\n

        Returns:
            DataFrame: Returns pandas DataFrame with calculated values
        &#34;&#34;&#34;

        prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
        interest_rate_period = self.interest_rate / 1200

        annuity_payment = self.amount * interest_rate_period / (1 - 1 / (1 + interest_rate_period)**self.period ) #Monthly payment

        df = pd.DataFrame(columns = [
        &#39;Year:Period&#39;, 
        &#39;Amortization&#39;,
        &#39;Interest expense&#39;,
        &#39;Payment&#39;,
        &#39;Remaining debt&#39;
        ])
        
        for i in range(0, self.period):    
            
            interest_exp = prev_rem_debt * interest_rate_period
            amortization = annuity_payment - interest_exp
            remaining_debt = prev_rem_debt - amortization
            prev_rem_debt = remaining_debt

            new_row = {
                &#39;Month:Period&#39;: i + 1,
                &#39;Amortization&#39;: amortization,
                &#39;Interest expense&#39;: interest_exp,
                &#39;Payment&#39;: annuity_payment,
                &#39;Remaining debt&#39;: prev_rem_debt,
            }
            
            df = df.append(new_row, ignore_index=True)
            df = df.round(2)
            df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )

        return df

    def get_summary(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and returns a dictionary with summary statistics.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)
        Returns:
            dict: Returns a dictionaty with the following keys: \
                &#39;total_cost&#39; (Total cost of the loan), &#39;average_interest_exp&#39; (Average interest expense),\
                     &#39;average_monthly_pmt&#39; (Average monthly payment), &#39;total_interest_exp&#39; (Sum of interest payments)
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
            average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
            total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
            total_cost = round((df[&#39;Payment&#39;].sum()), 2)
            summary = {
                &#39;total_cost&#39;: total_cost, 
                &#39;average_interest_exp&#39;: average_interest_exp, 
                &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
                &#39;total_interest_exp&#39;: total_interest_exp
                }
            return summary
        
        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
            average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
            total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
            total_cost = round((df[&#39;Payment&#39;].sum()), 2)
            summary = {
                &#39;total_cost&#39;: total_cost, 
                &#39;average_interest_exp&#39;: average_interest_exp, 
                &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
                &#39;total_interest_exp&#39;: total_interest_exp
                }
            return summary


    def to_html(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to html markup.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            str: Returns calculated amortization table within a string in html/css markup.
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            return df.to_html()

        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            return df.to_html()

    def to_json(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to JSON.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            str: Returns calculated amortization table within a string in JSON format.
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            return df.to_json()

        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            return df.to_json()
    
    def to_csv(self, path: str, method=&#34;annuity&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to .csv file.

        Args:
            path (str): Absolute path to a folder where the script should export [method]_amortization.csv file. For unix &#39;/tmp/&#39; or Windows &#39;C:/User/Andy/Desktop/&#39; (Only forward slash accepted)
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            print: prints success message after the exported file was recorded on your server/local machine.
        &#34;&#34;&#34;

        full_path = fr&#39;{path}&#39; + f&#39;{method}_amortization.csv&#39;

        if method == &#39;straight&#39;:
            self.straight_amortization().to_csv(full_path, index = False, header=True)
            return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)

        if method == &#39;annuity&#39;:
            self.annuity_amortization().to_csv(full_path, index = False, header=True)
            return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="main.Amortizer"><code class="flex name class">
<span>class <span class="ident">Amortizer</span></span>
<span>(</span><span>amount: float, period: int, interest_rate: float)</span>
</code></dt>
<dd>
<div class="desc"><p>This Class instantiates an new object for a loan ammortization calculations. Attributes are used as initial values for two </p>
<p>implemented methods of payment schedule: <strong>annuity</strong> and classic <strong>straight</strong> amortization.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>Loan body (i.e. 100000 or 900.50)</dd>
<dt><strong><code>period</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of months (i.e. 5 years = 60)</dd>
<dt><strong><code>interest_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Interest rate in percents (i.e. if 9% then 9 without '%' sign. Decimal types: 9.5 are allowed.)</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>straight_amortization(): Calculates amortization table with straight amortization and returns a dataframe. </p>
<p>annuity_amortization(): Calculates amortization table with annuity payments and returns a dataframe. </p>
<p>get_summary(method="straight"): Calculates amortization dataframe and returns a dictionary with summary statistics. </p>
<p>to_html(method="straight"): Calculates amortization dataframe and exports results to a string with html markup.
</p>
<p>to_json(method="straight"): Calculates amortization dataframe and exports results to a string with JSON object. </p>
<p>to_csvpath: str, method="annuity"): Calculates amortization dataframe and exports results to .csv file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Amortizer:
    &#34;&#34;&#34;
    This Class instantiates an new object for a loan ammortization calculations. Attributes are used as initial values for two \n
    implemented methods of payment schedule: **annuity** and classic **straight** amortization.

    Attributes:
        amount (float): Loan body (i.e. 100000 or 900.50)
        period (int): Number of months (i.e. 5 years = 60)
        interest_rate (float): Interest rate in percents (i.e. if 9% then 9 without &#39;%&#39; sign. Decimal types: 9.5 are allowed.)

    Methods:
        straight_amortization(): Calculates amortization table with straight amortization and returns a dataframe. \n
        annuity_amortization(): Calculates amortization table with annuity payments and returns a dataframe. \n
        get_summary(method=&#34;straight&#34;): Calculates amortization dataframe and returns a dictionary with summary statistics. \n
        to_html(method=&#34;straight&#34;): Calculates amortization dataframe and exports results to a string with html markup.  \n
        to_json(method=&#34;straight&#34;): Calculates amortization dataframe and exports results to a string with JSON object. \n
        to_csvpath: str, method=&#34;annuity&#34;): Calculates amortization dataframe and exports results to .csv file. \n

    &#34;&#34;&#34;

    def __init__(self, amount: float, period: int, interest_rate: float):

        args = [amount, period, interest_rate]
        for arg in args:
            if type(arg) == str:
                raise TypeError(&#34;Arguments must be Integer or Float&#34;)

        if period &lt;= 0:
            raise ValueError(&#34;Period cannot be less than 0 months&#34;)
        if interest_rate &gt; 100 or interest_rate &lt; 0:
            raise ValueError(&#34;Interest rate per year cannot be more than 100 or less then 0%&#34;)

        self.amount = float(amount)
        self.period = period
        self.interest_rate = float(interest_rate)

    def straight_amortization(self):
        &#34;&#34;&#34;Calculates amortization table with straight amortization.
        A loan amortized in the classic method comprises a series of payments made between equal time intervals.\n
        Classic amortization means that the borrower will amortize an equal amount each payment period, but the interest will differ in size. \n
        Due to that the interest rate is based on the outstanding debt, the interest paid each payment period is going to decrease the further in to the loan period you get. \n
        Which means that in the beginning of the loan period, the payments will be the biggest and  in the end of the loan period the payments will get smaller and smaller.\n

        Returns:
            DataFrame: Returns pandas DataFrame with calculated values
        &#34;&#34;&#34;
       
        amortization = self.amount / self.period #constant amortization per month
        prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
        interest_rate_period = self.interest_rate / 1200

        df = pd.DataFrame(columns = [
        &#39;Year:Period&#39;, 
        &#39;Amortization&#39;,
        &#39;Interest expense&#39;,
        &#39;Payment&#39;,
        &#39;Remaining debt&#39;
        ])
        
        for i in range(0, self.period):    
            
            interest_exp = prev_rem_debt * interest_rate_period
            remaining_debt = prev_rem_debt - amortization
            prev_rem_debt = remaining_debt
            payment_amount = interest_exp + amortization
            new_row = {
                &#39;Month:Period&#39;: i + 1,
                &#39;Amortization&#39;: amortization,
                &#39;Interest expense&#39;: interest_exp,
                &#39;Payment&#39;: payment_amount,
                &#39;Remaining debt&#39;: prev_rem_debt,
            }
            
            df = df.append(new_row, ignore_index=True)
            df = df.round(2)
            df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )
        
        return df



    def annuity_amortization(self):
        &#34;&#34;&#34;Calculates amortization table with annuity payments\n
        A loan amortized in the annuity method comprises a series of payments made between equal time intervals. \n
        This amortization type is used to pay an equal amount each payment period. In the beginning of the loan period, \n
        the payments will consist of a bigger part interest and a smaller part amortization.\n
         The further towards the end of the loan period you will come, the bigger part of the payment will be amortization and the smaller part interest.\n

        Returns:
            DataFrame: Returns pandas DataFrame with calculated values
        &#34;&#34;&#34;

        prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
        interest_rate_period = self.interest_rate / 1200

        annuity_payment = self.amount * interest_rate_period / (1 - 1 / (1 + interest_rate_period)**self.period ) #Monthly payment

        df = pd.DataFrame(columns = [
        &#39;Year:Period&#39;, 
        &#39;Amortization&#39;,
        &#39;Interest expense&#39;,
        &#39;Payment&#39;,
        &#39;Remaining debt&#39;
        ])
        
        for i in range(0, self.period):    
            
            interest_exp = prev_rem_debt * interest_rate_period
            amortization = annuity_payment - interest_exp
            remaining_debt = prev_rem_debt - amortization
            prev_rem_debt = remaining_debt

            new_row = {
                &#39;Month:Period&#39;: i + 1,
                &#39;Amortization&#39;: amortization,
                &#39;Interest expense&#39;: interest_exp,
                &#39;Payment&#39;: annuity_payment,
                &#39;Remaining debt&#39;: prev_rem_debt,
            }
            
            df = df.append(new_row, ignore_index=True)
            df = df.round(2)
            df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )

        return df

    def get_summary(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and returns a dictionary with summary statistics.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)
        Returns:
            dict: Returns a dictionaty with the following keys: \
                &#39;total_cost&#39; (Total cost of the loan), &#39;average_interest_exp&#39; (Average interest expense),\
                     &#39;average_monthly_pmt&#39; (Average monthly payment), &#39;total_interest_exp&#39; (Sum of interest payments)
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
            average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
            total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
            total_cost = round((df[&#39;Payment&#39;].sum()), 2)
            summary = {
                &#39;total_cost&#39;: total_cost, 
                &#39;average_interest_exp&#39;: average_interest_exp, 
                &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
                &#39;total_interest_exp&#39;: total_interest_exp
                }
            return summary
        
        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
            average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
            total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
            total_cost = round((df[&#39;Payment&#39;].sum()), 2)
            summary = {
                &#39;total_cost&#39;: total_cost, 
                &#39;average_interest_exp&#39;: average_interest_exp, 
                &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
                &#39;total_interest_exp&#39;: total_interest_exp
                }
            return summary


    def to_html(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to html markup.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            str: Returns calculated amortization table within a string in html/css markup.
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            return df.to_html()

        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            return df.to_html()

    def to_json(self, method=&#34;straight&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to JSON.

        Args:
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            str: Returns calculated amortization table within a string in JSON format.
        &#34;&#34;&#34;        

        if method == &#39;straight&#39;:
            df = self.straight_amortization()
            return df.to_json()

        if method == &#39;annuity&#39;:
            df = self.annuity_amortization()
            return df.to_json()
    
    def to_csv(self, path: str, method=&#34;annuity&#34;):
        &#34;&#34;&#34;Calculates amortization dataframe and exports results to .csv file.

        Args:
            path (str): Absolute path to a folder where the script should export [method]_amortization.csv file. For unix &#39;/tmp/&#39; or Windows &#39;C:/User/Andy/Desktop/&#39; (Only forward slash accepted)
            method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

        Returns:
            print: prints success message after the exported file was recorded on your server/local machine.
        &#34;&#34;&#34;

        full_path = fr&#39;{path}&#39; + f&#39;{method}_amortization.csv&#39;

        if method == &#39;straight&#39;:
            self.straight_amortization().to_csv(full_path, index = False, header=True)
            return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)

        if method == &#39;annuity&#39;:
            self.annuity_amortization().to_csv(full_path, index = False, header=True)
            return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="main.Amortizer.annuity_amortization"><code class="name flex">
<span>def <span class="ident">annuity_amortization</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization table with annuity payments</p>
<p>A loan amortized in the annuity method comprises a series of payments made between equal time intervals. </p>
<p>This amortization type is used to pay an equal amount each payment period. In the beginning of the loan period, </p>
<p>the payments will consist of a bigger part interest and a smaller part amortization.</p>
<p>The further towards the end of the loan period you will come, the bigger part of the payment will be amortization and the smaller part interest.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Returns pandas DataFrame with calculated values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annuity_amortization(self):
    &#34;&#34;&#34;Calculates amortization table with annuity payments\n
    A loan amortized in the annuity method comprises a series of payments made between equal time intervals. \n
    This amortization type is used to pay an equal amount each payment period. In the beginning of the loan period, \n
    the payments will consist of a bigger part interest and a smaller part amortization.\n
     The further towards the end of the loan period you will come, the bigger part of the payment will be amortization and the smaller part interest.\n

    Returns:
        DataFrame: Returns pandas DataFrame with calculated values
    &#34;&#34;&#34;

    prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
    interest_rate_period = self.interest_rate / 1200

    annuity_payment = self.amount * interest_rate_period / (1 - 1 / (1 + interest_rate_period)**self.period ) #Monthly payment

    df = pd.DataFrame(columns = [
    &#39;Year:Period&#39;, 
    &#39;Amortization&#39;,
    &#39;Interest expense&#39;,
    &#39;Payment&#39;,
    &#39;Remaining debt&#39;
    ])
    
    for i in range(0, self.period):    
        
        interest_exp = prev_rem_debt * interest_rate_period
        amortization = annuity_payment - interest_exp
        remaining_debt = prev_rem_debt - amortization
        prev_rem_debt = remaining_debt

        new_row = {
            &#39;Month:Period&#39;: i + 1,
            &#39;Amortization&#39;: amortization,
            &#39;Interest expense&#39;: interest_exp,
            &#39;Payment&#39;: annuity_payment,
            &#39;Remaining debt&#39;: prev_rem_debt,
        }
        
        df = df.append(new_row, ignore_index=True)
        df = df.round(2)
        df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )

    return df</code></pre>
</details>
</dd>
<dt id="main.Amortizer.get_summary"><code class="name flex">
<span>def <span class="ident">get_summary</span></span>(<span>self, method='straight')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization dataframe and returns a dictionary with summary statistics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify one of the following methods to calculate the amortization table: 'straight' or 'annuity' (default)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Returns a dictionaty with the following keys:
'total_cost' (Total cost of the loan), 'average_interest_exp' (Average interest expense),
'average_monthly_pmt' (Average monthly payment), 'total_interest_exp' (Sum of interest payments)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_summary(self, method=&#34;straight&#34;):
    &#34;&#34;&#34;Calculates amortization dataframe and returns a dictionary with summary statistics.

    Args:
        method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)
    Returns:
        dict: Returns a dictionaty with the following keys: \
            &#39;total_cost&#39; (Total cost of the loan), &#39;average_interest_exp&#39; (Average interest expense),\
                 &#39;average_monthly_pmt&#39; (Average monthly payment), &#39;total_interest_exp&#39; (Sum of interest payments)
    &#34;&#34;&#34;        

    if method == &#39;straight&#39;:
        df = self.straight_amortization()
        average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
        average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
        total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
        total_cost = round((df[&#39;Payment&#39;].sum()), 2)
        summary = {
            &#39;total_cost&#39;: total_cost, 
            &#39;average_interest_exp&#39;: average_interest_exp, 
            &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
            &#39;total_interest_exp&#39;: total_interest_exp
            }
        return summary
    
    if method == &#39;annuity&#39;:
        df = self.annuity_amortization()
        average_interest_exp = round(df[&#39;Interest expense&#39;].mean(), 2)
        average_monthly_pmt = round(df[&#39;Payment&#39;].mean(), 2)
        total_interest_exp = round((df[&#39;Interest expense&#39;].sum()), 2)
        total_cost = round((df[&#39;Payment&#39;].sum()), 2)
        summary = {
            &#39;total_cost&#39;: total_cost, 
            &#39;average_interest_exp&#39;: average_interest_exp, 
            &#39;average_monthly_pmt&#39;: average_monthly_pmt, 
            &#39;total_interest_exp&#39;: total_interest_exp
            }
        return summary</code></pre>
</details>
</dd>
<dt id="main.Amortizer.straight_amortization"><code class="name flex">
<span>def <span class="ident">straight_amortization</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization table with straight amortization.
A loan amortized in the classic method comprises a series of payments made between equal time intervals.</p>
<p>Classic amortization means that the borrower will amortize an equal amount each payment period, but the interest will differ in size. </p>
<p>Due to that the interest rate is based on the outstanding debt, the interest paid each payment period is going to decrease the further in to the loan period you get. </p>
<p>Which means that in the beginning of the loan period, the payments will be the biggest and
in the end of the loan period the payments will get smaller and smaller.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Returns pandas DataFrame with calculated values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def straight_amortization(self):
    &#34;&#34;&#34;Calculates amortization table with straight amortization.
    A loan amortized in the classic method comprises a series of payments made between equal time intervals.\n
    Classic amortization means that the borrower will amortize an equal amount each payment period, but the interest will differ in size. \n
    Due to that the interest rate is based on the outstanding debt, the interest paid each payment period is going to decrease the further in to the loan period you get. \n
    Which means that in the beginning of the loan period, the payments will be the biggest and  in the end of the loan period the payments will get smaller and smaller.\n

    Returns:
        DataFrame: Returns pandas DataFrame with calculated values
    &#34;&#34;&#34;
   
    amortization = self.amount / self.period #constant amortization per month
    prev_rem_debt = self.amount #remaining debt from last period (initial = loan amount)
    interest_rate_period = self.interest_rate / 1200

    df = pd.DataFrame(columns = [
    &#39;Year:Period&#39;, 
    &#39;Amortization&#39;,
    &#39;Interest expense&#39;,
    &#39;Payment&#39;,
    &#39;Remaining debt&#39;
    ])
    
    for i in range(0, self.period):    
        
        interest_exp = prev_rem_debt * interest_rate_period
        remaining_debt = prev_rem_debt - amortization
        prev_rem_debt = remaining_debt
        payment_amount = interest_exp + amortization
        new_row = {
            &#39;Month:Period&#39;: i + 1,
            &#39;Amortization&#39;: amortization,
            &#39;Interest expense&#39;: interest_exp,
            &#39;Payment&#39;: payment_amount,
            &#39;Remaining debt&#39;: prev_rem_debt,
        }
        
        df = df.append(new_row, ignore_index=True)
        df = df.round(2)
        df[&#39;Remaining debt&#39;] = df[&#39;Remaining debt&#39;].map(lambda x: 0 if x&lt;0 else x )
    
    return df</code></pre>
</details>
</dd>
<dt id="main.Amortizer.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self, path: str, method='annuity')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization dataframe and exports results to .csv file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Absolute path to a folder where the script should export [method]_amortization.csv file. For unix '/tmp/' or Windows 'C:/User/Andy/Desktop/' (Only forward slash accepted)</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify one of the following methods to calculate the amortization table: 'straight' or 'annuity' (default)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>print</code></dt>
<dd>prints success message after the exported file was recorded on your server/local machine.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self, path: str, method=&#34;annuity&#34;):
    &#34;&#34;&#34;Calculates amortization dataframe and exports results to .csv file.

    Args:
        path (str): Absolute path to a folder where the script should export [method]_amortization.csv file. For unix &#39;/tmp/&#39; or Windows &#39;C:/User/Andy/Desktop/&#39; (Only forward slash accepted)
        method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

    Returns:
        print: prints success message after the exported file was recorded on your server/local machine.
    &#34;&#34;&#34;

    full_path = fr&#39;{path}&#39; + f&#39;{method}_amortization.csv&#39;

    if method == &#39;straight&#39;:
        self.straight_amortization().to_csv(full_path, index = False, header=True)
        return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)

    if method == &#39;annuity&#39;:
        self.annuity_amortization().to_csv(full_path, index = False, header=True)
        return print(f&#34;Data was recorded to {method}_amortization.csv at the following location: {path}&#34;)</code></pre>
</details>
</dd>
<dt id="main.Amortizer.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>self, method='straight')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization dataframe and exports results to html markup.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify one of the following methods to calculate the amortization table: 'straight' or 'annuity' (default)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Returns calculated amortization table within a string in html/css markup.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_html(self, method=&#34;straight&#34;):
    &#34;&#34;&#34;Calculates amortization dataframe and exports results to html markup.

    Args:
        method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

    Returns:
        str: Returns calculated amortization table within a string in html/css markup.
    &#34;&#34;&#34;        

    if method == &#39;straight&#39;:
        df = self.straight_amortization()
        return df.to_html()

    if method == &#39;annuity&#39;:
        df = self.annuity_amortization()
        return df.to_html()</code></pre>
</details>
</dd>
<dt id="main.Amortizer.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, method='straight')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates amortization dataframe and exports results to JSON.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify one of the following methods to calculate the amortization table: 'straight' or 'annuity' (default)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Returns calculated amortization table within a string in JSON format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, method=&#34;straight&#34;):
    &#34;&#34;&#34;Calculates amortization dataframe and exports results to JSON.

    Args:
        method (str, optional): Specify one of the following methods to calculate the amortization table: &#39;straight&#39; or &#39;annuity&#39; (default)

    Returns:
        str: Returns calculated amortization table within a string in JSON format.
    &#34;&#34;&#34;        

    if method == &#39;straight&#39;:
        df = self.straight_amortization()
        return df.to_json()

    if method == &#39;annuity&#39;:
        df = self.annuity_amortization()
        return df.to_json()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="main.Amortizer" href="#main.Amortizer">Amortizer</a></code></h4>
<ul class="">
<li><code><a title="main.Amortizer.annuity_amortization" href="#main.Amortizer.annuity_amortization">annuity_amortization</a></code></li>
<li><code><a title="main.Amortizer.get_summary" href="#main.Amortizer.get_summary">get_summary</a></code></li>
<li><code><a title="main.Amortizer.straight_amortization" href="#main.Amortizer.straight_amortization">straight_amortization</a></code></li>
<li><code><a title="main.Amortizer.to_csv" href="#main.Amortizer.to_csv">to_csv</a></code></li>
<li><code><a title="main.Amortizer.to_html" href="#main.Amortizer.to_html">to_html</a></code></li>
<li><code><a title="main.Amortizer.to_json" href="#main.Amortizer.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>